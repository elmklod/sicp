(define (apply-generic op . args)
  (define (raise-args args)
    (define (find-uppermost-level args)
      (fold-left (lambda (res arg)
                   (let ((lvl (level arg)))
                        (if (< res lvl)
                            res
                            lvl)))
                 (level (car args))
                 (cdr args)))
    (define (make-graded-arg arg level)
      (cons arg level))
    (define (argument graded-arg)
      (car graded-arg))
    (define (level graded-arg)
      (cdr graded-arg))
    (define (type-level arg)
      (define (iter arg level)
        (let ((raise (get 'raise (list (type-tag arg)))))
          (if raise
              (iter (raise arg) (+ level 1))
              level)))
      (iter arg 0))
    (define (raise-n-times arg n)
     (if (= n 0)
         arg
         (raise-n-times (raise arg) (- n 1))))
    (define (grade-args)
     (let ((graded-to-top (map (lambda (arg)
                                 (make-graded-arg
                                   arg
                                   (type-level arg)))
                               args)))
          (let ((uppermost-level (find-uppermost-level graded-to-top)))
               (map (lambda (graded-arg) (make-graded-arg (argument graded-arg)
                                                          (- (level graded-arg)
                                                             uppermost-level)))
                    graded-to-top))))
    (if (null? args)
       '()
       (map (lambda (graded-arg) (raise-n-times (argument graded-arg)
                                                (level graded-arg)))
            (grade-args))))
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (let ((raised-args (raise-args args)))
             (if (not (equal? args raised-args))
                 (apply apply-generic (cons op raised-args))
                 (error
                  "No method for these types"
                   (list op type-tags))))))))

; Counting of the levels starts from the top

(define (raise-args args)
  (define (find-uppermost-level args)
    (fold-left (lambda (res arg)
                 (let ((lvl (level arg)))
                      (if (< res lvl)
                          res
                          lvl)))
               (level (car args))
               (cdr args)))
  (define (make-graded-arg arg level)
    (cons arg level))
  (define (argument graded-arg)
    (car graded-arg))
  (define (level graded-arg)
    (cdr graded-arg))
  (define (type-level arg)
    (define (iter arg level)
      (let ((raise (get 'raise (list (type-tag arg)))))
        (if raise
            (iter (raise arg) (+ level 1))
            level)))
    (iter arg 0))
  (define (raise-n-times arg n)
   (if (= n 0)
       arg
       (raise-n-times (raise arg) (- n 1))))
  (define (grade-args)
   (let ((graded-to-top (map (lambda (arg)
                               (make-graded-arg
                                 arg
                                 (type-level arg)))
                             args)))
        (let ((uppermost-level (find-uppermost-level graded-to-top)))
             (map (lambda (graded-arg) (make-graded-arg (argument graded-arg)
                                                        (- (level graded-arg)
                                                           uppermost-level)))
                  graded-to-top))))
  (if (null? args)
     '()
     (map (lambda (graded-arg) (raise-n-times (argument graded-arg)
                                              (level graded-arg)))
          (grade-args))))


(define (raise-args args)

  (if (null? args)
     '()
     (map (lambda (graded-arg) (raise-n-times (argument graded-arg)
                                              (level graded-arg)))
          (grade-args args))))
