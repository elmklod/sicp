; For every pattern to be evaluated, 2 things must be done:
; If the pattern is being evaluated, the frame relative to which it is being evaluated must be compared with the current frame
; by instatiating the pattern with the value from the frame (recursively until there are no intermediate variables)
; Every unassigned pattern variable must be substituted for a unique specific object
; if two instantiations are equal (using equal? predicate)
; then the system is entering a loop and should stop.
; When the pattern and frame combination is new, it is stored in some data structure to do the step 1 with new instances of this pattern
; that are encountered later in the evaluation process of this pattern
; I.e. the history is passed from tranformation to tranformation until the result is the stream of frames
; Compound queries only share their own history with their clauses.
; clauses itself do not share history between themselves.
; otherwise redundant, but valid queries will fail
; Such as (and (wheel (Bitdiddle Ben))
;              (wheel (Bitdiddle Ben)))
; There are subtler examples as in some inequalities
; After each evaluation resulting in the stream of frames
; the history for the original query that resulted in this stream is erased

; Without instantiations it is impossible to compare such queries as
; (wheel ?d) and (wheel ?m)
; or not, depending on the unifier implementation

; There may be more than one combination of one pattern with a frame,
; each time frame bindings for relevant(in the current pattern) pattern must be different
;(in at least one value, including unassigned variables)
; without it there is no way to detect loops of this structure:
; (rule (wheel ?d)
;    (wheel ?m))
; or there is, depending on the implementation of the unification.

; Instead of storing pattern + frame, it is much more efficient to store an instantiation of pattern with the relevant values
; this way no confusion on the storing multiple combinations is aroused, because only unique instantiations are stored
; First the history check, then matching, unification
