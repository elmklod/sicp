; For every pattern to be evaluated, 2 things must be done:
; If the pattern is being evaluated, the frame relative to which it is being evaluated must be compared with the current frame
; by instantiating the pattern with the value from the frame (recursively until there are no intermediate variables)
; Every unassigned pattern variable must be substituted for a unique specific object
; if two instantiations are equal (using equal? predicate)
; then the system is entering a loop and should stop.
; When the pattern and frame combination is new, it is stored in some data structure to do the step 1 with new instances of this pattern
; that are encountered later in the evaluation process of this pattern
; I.e. the history is passed from tranformation to tranformation until the result is the stream of frames
; Compound queries only share their own history with their clauses.
; clauses itself do not share history between themselves.
; otherwise redundant, but valid queries will fail
; Such as (and (wheel (Bitdiddle Ben))
;              (wheel (Bitdiddle Ben)))
; There are subtler examples as in some inequalities
; After each evaluation resulting in the stream of frames
; the history for the original query that resulted in this stream is erased

; Without instantiations it is impossible to compare such queries as
; (wheel ?d) and (wheel ?m)
; or not, depending on the unifier implementation

; There may be more than one combination of one pattern with a frame,
; each time frame bindings for relevant(in the current pattern) pattern must be different
;(in at least one value, including unassigned variables)
; without it there is no way to detect loops of this structure:
; (rule (wheel ?d)
;    (wheel ?m))
; or there is, depending on the implementation of the unification.

; Instead of storing pattern + frame, it is much more efficient to store an instantiation of pattern with the relevant values
; this way no confusion on the storing multiple combinations is aroused, because only unique instantiations are stored
; First the history check, then matching, unification

; The imperative way makes it hard to parallize
; It also requires more timely modifications (set! is extremely hard to use if one wants LAZY per-frame check
; esp. the removal of old values)

(define (apply-rules pattern frame)
  (stream-flatmap
   (lambda (rule)
     (apply-a-rule
      rule
      pattern
      (check-and-update-hist frame pattern)))
   (fetch-rules pattern)))

(define (check-and-update-hist frame pattern)
  (define (repeated? inst)
   (memq inst (frame-history frame)))
  (define (update-history inst)
   (make-frame (frame-bindings frame)
               (cons inst (frame-history))))
  (let ((new-inst (instantiate
                   query
                   frame
                   (lambda (v f) 'unbound))))
   (if (repeated? new-inst)
       (error "A loop is detected" pattern frame)
       (update-history new-inst))))

; May look confusing
; (define (check-and-update-hist frame pattern)
;   (let ((new-inst (instantiate
;                   query
;                   frame
;                   (lambda (v f) 'unbound))))
;    (define (repeated?)
;     (memq new-inst (frame-history frame)))
;    (define (update-history)
;     (make-frame (frame-bindings frame)
;                 (cons new-inst (frame-history))))
;    (if (repeated?)
;        (error "A loop is detected" pattern frame)
;        (update-history))))

(define (make-frame bindings history)
 (cons bindings history))

(define (frame-bindings frame)
 (car frame))

(define (frame-history frame)
 (cdr frame))

(define (binding-in-frame variable frame)
  (assoc variable (frame-bindings frame)))

(define (extend variable value frame)
 (make-frame (cons
              (make-binding variable value)
              (frame-bindings frame))
             (frame-history frame)))

(define (query-driver-loop)
  (prompt-for-input input-prompt)
  (let ((q (query-syntax-process (read))))
    (cond ((assertion-to-be-added? q)
           (add-rule-or-assertion!
            (add-assertion-body q))
           (newline)
           (display
            "Assertion added to data base.")
           (query-driver-loop))
          (else
           (newline)
           (display output-prompt)
           (display-stream
            (stream-map
             (lambda (frame)
               (instantiate
                q
                frame
                (lambda (v f)
                  (contract-question-mark v))))
             (qeval q (singleton-stream the-empty-frame)))
           (query-driver-loop)))))

(define the-empty-frame '(() . ())) ; (cons '() '()) or '(())
