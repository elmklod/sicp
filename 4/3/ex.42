(define (liars)
  (define (amb-assign-truth two-statements)
    (amb two-statements
         (reverse two-statements)))
  (define (remove-duplicates L)
    (define (iter L result)
      (if (null? L)
          result
          (let ((current-elem (car L)))
            (iter (filter (lambda (element)
                            (not (equal? element current-elem)))
                          (cdr L))
                  (cons current-elem result)))))
    (iter L '()))
  (define (contradicts? statements-1 statements-2)
    (or (equal? (car statements-1) ; car is truth
                (cadr statements-2)) ; cadr is falsehood
        (equal? (car statements-2)
                (cadr statements-1))
        (and (eq? (caar statements-1)
                  (caar statements-2))
             (not (= (cadar statements-1)
                     (cadar statements-2))))
        (and (not (eq? (caar statements-1)
                       (caar statements-2)))
             (= (cadar statements-1)
                (cadar statements-2)))))
  (let ((betty (amb-assign-truth (list '(k 2) '(b 3))))
        (ethel (amb-assign-truth (list '(e 1) '(j 2)))))
    (require (not (contradicts? betty ethel)))
    (let ((joan (amb-assign-truth (list '(j 3) '(e 5)))))
      (require (not (contradicts? betty joan)))
      (require (not (contradicts? ethel joan))); statements are split for clarity
      (let ((kitty (amb-assign-truth (list '(k 2) '(m 4)))))
        (require (not (contradicts? betty kitty)))
        (require (not (contradicts? ethel kitty)))
        (require (not (contradicts? joan kitty)))
        (let ((mary (amb-assign-truth (list '(m 4) '(b 1)))))
          (require (not (contradicts? betty mary)))
          (require (not (contradicts? ethel mary)))
          (require (not (contradicts? joan mary)))
          (require (not (contradicts? kitty mary)))
          (let* ((all-statements (list kitty mary ethel joan betty))
                 (falsehoods (remove-duplicates (map cadr all-statements)))
                 (truths (remove-duplicates (map car all-statements)))
                 (girls-with-rank (map car truths))
                 (taken-ranks (map cadr truths))
                 (all-girls '(k b e j m))
                 (all-ranks '(1 2 3 4 5)))
            (define (complete-ranking remaining-girls
                                      remaining-ranks
                                      ranking)
              (define (amb-choose L)
                (if (null? L)
                    (amb)
                    (amb (car L)
                         (amb-choose (cdr L)))))
              (if (null? remaining-girls)
                  ranking
                  (let* ((girl (amb-choose remaining-girls))
                         (rank (amb-choose remaining-ranks))
                         (truth (list girl rank)))
                    (require (not (member truth falsehoods)))
                    (complete-ranking (filter (lambda (g)
                                                (not (eq? g girl)))
                                              remaining-girls)
                                      (filter (lambda (r)
                                                (not (eq? r rank)))
                                              remaining-ranks)
                                      (cons truth ranking)))))
            (complete-ranking (filter (lambda (girl)
                                       (not (memq girl girls-with-rank)))
                                      all-girls)
                              (filter (lambda (rank)
                                       (not (memq rank taken-ranks)))
                                      all-ranks)
                              truths)))))))

;;; Starting a new problem
;;; Amb-Eval value:
((k 1) (b 3) (e 5) (j 2) (m 4))


--------------------------
add to primitives:
(list 'xor (lambda (a b) (and (or a b) (not (and a b)))))

(define (liars)
  (let ((betty (amb 1 2 3 4 5))
        (ethel (amb 1 2 3 4 5))
        (joan (amb 1 2 3 4 5))
        (kitty (amb 1 2 3 4 5))
        (mary (amb 1 2 3 4 5)))
  (require (distinct? (list betty ethel joan kitty mary)))
  (require (xor (= kitty 2) (= betty 3)))
  (require (xor (= ethel 1) (= joan 2)))
  (require (xor (= joan 3) (= ethel 5)))
  (require (xor (= kitty 2) (= mary 4)))
  (require (xor (= mary 4) (= betty 1)))
  (list (list 'betty betty)
  (list 'ethel ethel)
  (list 'joan joan)
  (list 'kitty kitty)
  (list 'mary mary))))

(define (distinct? items)
    (cond ((null? items) true)
          ((null? (cdr items)) true)
          ((member (car items) (cdr items)) false)
          (else (distinct? (cdr items)))))
